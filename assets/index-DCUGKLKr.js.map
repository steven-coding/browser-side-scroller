{"version":3,"file":"index-DCUGKLKr.js","sources":["../../src/level.ts","../../src/game-over-message.ts","../../src/browser-side-scroller.ts","../../src/main.ts"],"sourcesContent":["interface Obstacle {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n    sprite: HTMLImageElement;\n    type: string;\n}\n\ninterface ThemeConfig {\n    name: string;\n    spritePath: string;\n    background: {\n        skyGradient: { top: string; bottom: string };\n        mountains: {\n            color: string;\n            parallaxSpeed: number;\n            points: Array<{ x: number; y: number }>;\n        };\n    };\n    ground: {\n        color: string;\n        textureColor: string;\n        height: number;\n        textureSize: number;\n        textureDensity: number;\n    };\n    obstacles: {\n        types: Array<{\n            name: string;\n            width: number;\n            height: number;\n            weight: number;\n        }>;\n        generation: {\n            count: number;\n            minDistance: number;\n            maxDistance: number;\n            startDistance: number;\n            safeZoneDistance: number;\n            doubleObstacleChance: number;\n            doubleObstacleSpacing: number;\n        };\n        fallbackColor: string;\n    };\n    world: {\n        width: number;\n    };\n}\n\nexport class Level {\n    private obstacles: Obstacle[] = [];\n    private sprites: { [key: string]: HTMLImageElement } = {};\n    private theme!: ThemeConfig;\n    private canvasHeight: number;\n    private cameraX: number = 0;\n    private lastObstacleX: number = 0;\n\n    constructor(canvasHeight: number, themePath: string = '/themes/desert-theme.json') {\n        this.canvasHeight = canvasHeight;\n        this.loadTheme(themePath);\n    }\n\n    private async loadTheme(themePath: string): Promise<void> {\n        try {\n            const response = await fetch(themePath);\n            this.theme = await response.json();\n            this.loadSprites();\n            this.generateInitialObstacles();\n        } catch (error) {\n            console.error('Failed to load theme:', error);\n            this.loadDefaultTheme();\n        }\n    }\n\n    private loadDefaultTheme(): void {\n        this.theme = {\n            name: 'Desert',\n            spritePath: 'sprites/world/desert',\n            background: {\n                skyGradient: { top: '#FFE4B5', bottom: '#DEB887' },\n                mountains: {\n                    color: '#CD853F',\n                    parallaxSpeed: 0.3,\n                    points: [\n                        { x: 0, y: 150 },\n                        { x: 200, y: 200 },\n                        { x: 400, y: 180 },\n                        { x: 600, y: 220 },\n                        { x: 800, y: 160 },\n                        { x: 1000, y: 150 }\n                    ]\n                }\n            },\n            ground: {\n                color: '#F4A460',\n                textureColor: '#DEB887',\n                height: 50,\n                textureSize: 20,\n                textureDensity: 0.7\n            },\n            obstacles: {\n                types: [\n                    { name: 'cactus', width: 60, height: 120, weight: 1.0 },\n                    { name: 'rock', width: 80, height: 50, weight: 1.0 },\n                    { name: 'tumbleweed', width: 70, height: 70, weight: 1.0 }\n                ],\n                generation: {\n                    count: 15,\n                    minDistance: 400,\n                    maxDistance: 800,\n                    startDistance: 200,\n                    safeZoneDistance: 1000,\n                    doubleObstacleChance: 0.3,\n                    doubleObstacleSpacing: 10\n                },\n                fallbackColor: '#8B4513'\n            },\n            world: { width: 2000 }\n        };\n        this.loadSprites();\n        this.generateInitialObstacles();\n    }\n\n    private loadSprites(): void {\n        if (!this.theme) return;\n        \n        this.theme.obstacles.types.forEach(obstacleType => {\n            const img = new Image();\n            img.src = `/${this.theme.spritePath}/${obstacleType.name}.svg`;\n            this.sprites[obstacleType.name] = img;\n        });\n    }\n\n    private generateInitialObstacles(): void {\n        if (!this.theme) return;\n        \n        const config = this.theme.obstacles;\n        let currentX = config.generation.startDistance + config.generation.safeZoneDistance;\n        \n        for (let i = 0; i < config.generation.count; i++) {\n            currentX = this.generateObstacleAtPosition(currentX);\n        }\n        \n        this.lastObstacleX = currentX;\n    }\n\n    private generateObstacleAtPosition(currentX: number): number {\n        if (!this.theme) return currentX;\n        \n        const config = this.theme.obstacles;\n        const obstacleType = config.types[Math.floor(Math.random() * config.types.length)];\n        \n        const y = this.canvasHeight - this.theme.ground.height - obstacleType.height;\n        \n        // Generate first obstacle\n        this.obstacles.push({\n            x: currentX,\n            y: y,\n            width: obstacleType.width,\n            height: obstacleType.height,\n            sprite: this.sprites[obstacleType.name],\n            type: obstacleType.name\n        });\n        \n        let nextX = currentX;\n        \n        // Check if we should generate a double obstacle\n        if (Math.random() < config.generation.doubleObstacleChance) {\n            const secondObstacleType = config.types[Math.floor(Math.random() * config.types.length)];\n            const secondY = this.canvasHeight - this.theme.ground.height - secondObstacleType.height;\n            \n            nextX = currentX + obstacleType.width + config.generation.doubleObstacleSpacing;\n            \n            // Generate second obstacle close behind the first\n            this.obstacles.push({\n                x: nextX,\n                y: secondY,\n                width: secondObstacleType.width,\n                height: secondObstacleType.height,\n                sprite: this.sprites[secondObstacleType.name],\n                type: secondObstacleType.name\n            });\n            \n            nextX += secondObstacleType.width;\n        } else {\n            nextX += obstacleType.width;\n        }\n        \n        return nextX + config.generation.minDistance + \n               Math.random() * (config.generation.maxDistance - config.generation.minDistance);\n    }\n\n    private generateNewObstacles(): void {\n        if (!this.theme) return;\n        \n        const generateAheadDistance = 1500; // Generate obstacles 1500px ahead of camera\n        \n        while (this.lastObstacleX < this.cameraX + generateAheadDistance) {\n            this.lastObstacleX = this.generateObstacleAtPosition(this.lastObstacleX);\n        }\n        \n        // Clean up obstacles that are far behind the camera\n        const cleanupDistance = 500;\n        this.obstacles = this.obstacles.filter(obstacle => \n            obstacle.x > this.cameraX - cleanupDistance\n        );\n    }\n\n    public render(ctx: CanvasRenderingContext2D, cameraX: number): void {\n        this.cameraX = cameraX;\n        \n        // Generate new obstacles as needed\n        this.generateNewObstacles();\n        \n        // Draw desert background\n        this.drawBackground(ctx);\n        \n        // Draw ground\n        this.drawGround(ctx);\n        \n        // Draw obstacles\n        this.drawObstacles(ctx);\n    }\n\n    private drawBackground(ctx: CanvasRenderingContext2D): void {\n        if (!this.theme) return;\n        \n        // Sky gradient\n        const gradient = ctx.createLinearGradient(0, 0, 0, this.canvasHeight);\n        gradient.addColorStop(0, this.theme.background.skyGradient.top);\n        gradient.addColorStop(1, this.theme.background.skyGradient.bottom);\n        ctx.fillStyle = gradient;\n        ctx.fillRect(0, 0, ctx.canvas.width, this.canvasHeight);\n        \n        // Mountains in background\n        ctx.fillStyle = this.theme.background.mountains.color;\n        ctx.beginPath();\n        \n        const parallaxOffset = -this.cameraX * this.theme.background.mountains.parallaxSpeed;\n        const points = this.theme.background.mountains.points;\n        \n        ctx.moveTo(parallaxOffset + points[0].x, this.canvasHeight - points[0].y);\n        \n        for (let i = 1; i < points.length; i++) {\n            ctx.lineTo(parallaxOffset + points[i].x, this.canvasHeight - points[i].y);\n        }\n        \n        ctx.lineTo(ctx.canvas.width, this.canvasHeight - points[points.length - 1].y);\n        ctx.lineTo(ctx.canvas.width, this.canvasHeight);\n        ctx.lineTo(0, this.canvasHeight);\n        ctx.closePath();\n        ctx.fill();\n    }\n\n    private drawGround(ctx: CanvasRenderingContext2D): void {\n        if (!this.theme) return;\n        \n        const ground = this.theme.ground;\n        \n        // Ground base\n        ctx.fillStyle = ground.color;\n        ctx.fillRect(0, this.canvasHeight - ground.height, ctx.canvas.width, ground.height);\n        \n        // Ground texture\n        ctx.fillStyle = ground.textureColor;\n        for (let x = 0; x < ctx.canvas.width; x += ground.textureSize) {\n            for (let y = this.canvasHeight - ground.height; y < this.canvasHeight; y += 10) {\n                if (Math.random() > ground.textureDensity) {\n                    ctx.fillRect(x + (this.cameraX % ground.textureSize), y, 2, 2);\n                }\n            }\n        }\n    }\n\n    private drawObstacles(ctx: CanvasRenderingContext2D): void {\n        if (!this.theme) return;\n        \n        this.obstacles.forEach(obstacle => {\n            const screenX = obstacle.x - this.cameraX;\n            \n            // Only draw if obstacle is visible on screen\n            if (screenX > -obstacle.width && screenX < ctx.canvas.width) {\n                if (obstacle.sprite && obstacle.sprite.complete) {\n                    ctx.drawImage(\n                        obstacle.sprite,\n                        screenX,\n                        obstacle.y,\n                        obstacle.width,\n                        obstacle.height\n                    );\n                } else {\n                    // Fallback rectangle while sprite loads\n                    ctx.fillStyle = this.theme.obstacles.fallbackColor;\n                    ctx.fillRect(screenX, obstacle.y, obstacle.width, obstacle.height);\n                }\n            }\n        });\n    }\n\n    public checkCollision(playerX: number, playerY: number, playerWidth: number, playerHeight: number): boolean {\n        for (const obstacle of this.obstacles) {\n            if (playerX < obstacle.x + obstacle.width &&\n                playerX + playerWidth > obstacle.x &&\n                playerY < obstacle.y + obstacle.height &&\n                playerY + playerHeight > obstacle.y) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public getWorldWidth(): number {\n        return this.theme ? this.theme.world.width : 2000;\n    }\n}","export class GameOverMessage {\n    private cupSprite: HTMLImageElement;\n    private animationTime: number = 0;\n    private fadeInDuration: number = 500; // ms\n    private cupBounce: number = 0;\n\n    constructor() {\n        this.cupSprite = new Image();\n        this.cupSprite.src = '/sprites/winners-cup.svg';\n    }\n\n    public render(\n        ctx: CanvasRenderingContext2D, \n        canvasWidth: number, \n        canvasHeight: number, \n        distance: number,\n        deltaTime: number\n    ): void {\n        this.animationTime += deltaTime;\n        \n        // Calculate fade-in opacity\n        const opacity = Math.min(1, this.animationTime / this.fadeInDuration);\n        \n        // Create overlay\n        ctx.fillStyle = `rgba(0, 0, 0, ${0.8 * opacity})`;\n        ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n        \n        if (opacity < 0.1) return; // Don't render content until fade starts\n        \n        const centerX = canvasWidth / 2;\n        const centerY = canvasHeight / 2;\n        \n        // Cup bounce animation\n        this.cupBounce = Math.sin(this.animationTime * 0.003) * 5;\n        \n        // Draw winner's cup\n        if (this.cupSprite.complete) {\n            const cupSize = 80;\n            const cupY = centerY - 120 + this.cupBounce;\n            \n            ctx.save();\n            ctx.globalAlpha = opacity;\n            ctx.drawImage(\n                this.cupSprite,\n                centerX - cupSize / 2,\n                cupY,\n                cupSize,\n                cupSize * (4/3) // Maintain aspect ratio (80x106)\n            );\n            ctx.restore();\n        }\n        \n        // Set text style with opacity\n        ctx.save();\n        ctx.globalAlpha = opacity;\n        ctx.textAlign = 'center';\n        ctx.fillStyle = '#FFD700';\n        \n        // Game Over title\n        ctx.font = 'bold 48px Arial';\n        ctx.fillText('GAME OVER', centerX, centerY + 20);\n        \n        // Distance achieved\n        ctx.fillStyle = '#FFFFFF';\n        ctx.font = 'bold 24px Arial';\n        ctx.fillText('Distance Reached:', centerX, centerY + 60);\n        \n        // Distance value with highlight\n        ctx.fillStyle = '#00FF88';\n        ctx.font = 'bold 32px Arial';\n        ctx.fillText(`${Math.floor(distance / 10)}m`, centerX, centerY + 100);\n        \n        // Achievement message\n        ctx.fillStyle = '#FFDD44';\n        ctx.font = '18px Arial';\n        const achievement = this.getAchievementMessage(distance);\n        ctx.fillText(achievement, centerX, centerY + 140);\n        \n        // Restart instruction with pulsing effect\n        const pulseAlpha = 0.7 + 0.3 * Math.sin(this.animationTime * 0.005);\n        ctx.fillStyle = `rgba(255, 255, 255, ${pulseAlpha})`;\n        ctx.font = 'bold 20px Arial';\n        ctx.fillText('Press ENTER to restart', centerX, centerY + 180);\n        \n        // Decorative elements\n        this.drawStars(ctx, centerX, centerY, opacity);\n        \n        ctx.restore();\n    }\n    \n    private getAchievementMessage(distance: number): string {\n        const meters = Math.floor(distance / 10);\n        \n        if (meters < 50) return \"Keep practicing!\";\n        if (meters < 100) return \"Getting warmed up!\";\n        if (meters < 200) return \"Nice run!\";\n        if (meters < 300) return \"Great distance!\";\n        if (meters < 500) return \"Excellent performance!\";\n        if (meters < 750) return \"Outstanding run!\";\n        if (meters < 1000) return \"Amazing achievement!\";\n        if (meters < 1500) return \"Legendary distance!\";\n        return \"SONIC SPEED MASTER!\";\n    }\n    \n    private drawStars(ctx: CanvasRenderingContext2D, centerX: number, centerY: number, opacity: number): void {\n        ctx.save();\n        ctx.globalAlpha = opacity * 0.6;\n        ctx.fillStyle = '#FFD700';\n        \n        const stars = [\n            { x: centerX - 150, y: centerY - 80, size: 3 },\n            { x: centerX + 140, y: centerY - 60, size: 2 },\n            { x: centerX - 180, y: centerY + 20, size: 2.5 },\n            { x: centerX + 170, y: centerY + 40, size: 3 },\n            { x: centerX - 120, y: centerY + 100, size: 2 },\n            { x: centerX + 130, y: centerY + 120, size: 2.5 }\n        ];\n        \n        stars.forEach((star, index) => {\n            const twinkle = Math.sin(this.animationTime * 0.004 + index) * 0.5 + 0.5;\n            const currentSize = star.size * (0.7 + 0.3 * twinkle);\n            \n            this.drawStar(ctx, star.x, star.y, currentSize);\n        });\n        \n        ctx.restore();\n    }\n    \n    private drawStar(ctx: CanvasRenderingContext2D, x: number, y: number, size: number): void {\n        ctx.beginPath();\n        for (let i = 0; i < 5; i++) {\n            const angle = (i * 4 * Math.PI) / 5;\n            const x1 = x + Math.cos(angle) * size;\n            const y1 = y + Math.sin(angle) * size;\n            \n            if (i === 0) {\n                ctx.moveTo(x1, y1);\n            } else {\n                ctx.lineTo(x1, y1);\n            }\n        }\n        ctx.closePath();\n        ctx.fill();\n    }\n    \n    public reset(): void {\n        this.animationTime = 0;\n        this.cupBounce = 0;\n    }\n}","import { Level } from './level';\nimport { GameOverMessage } from './game-over-message';\n\nexport class BrowserSideScroller {\n    private canvas: HTMLCanvasElement;\n    private ctx: CanvasRenderingContext2D;\n    private gameRunning: boolean = false;\n    private lastTime: number = 0;\n    private keys: { [key: string]: boolean } = {};\n    private playerSprite: HTMLImageElement;\n    private level: Level;\n    private cameraX: number = 0;\n    private gameSpeed: number = 2;\n    private playerSpritePath: string = '/sprites/sonic-player.svg';\n    private gameOverMessage: GameOverMessage;\n    private player: {\n        x: number;\n        y: number;\n        width: number;\n        height: number;\n        color: string;\n        velocityY: number;\n        isJumping: boolean;\n        jumpPower: number;\n        gravity: number;\n    };\n\n    constructor() {\n        this.canvas = document.getElementById('gameCanvas') as HTMLCanvasElement;\n        this.ctx = this.canvas.getContext('2d')!;\n        \n        this.setupCanvas();\n        \n        this.player = {\n            x: 50,\n            y: this.canvas.height - 130,\n            width: 80,\n            height: 80,\n            color: '#00ff00',\n            velocityY: 0,\n            isJumping: false,\n            jumpPower: 21.2,\n            gravity: 0.25\n        };\n\n        this.playerSprite = new Image();\n        this.loadPlayerSprite();\n\n        this.level = new Level(this.canvas.height);\n        this.gameOverMessage = new GameOverMessage();\n        this.setupEventListeners();\n    }\n\n    private loadPlayerSprite(spritePath?: string): void {\n        if (spritePath) {\n            this.playerSpritePath = spritePath;\n        }\n        this.playerSprite.src = this.playerSpritePath;\n    }\n\n    public setPlayerSprite(spritePath: string): void {\n        this.loadPlayerSprite(spritePath);\n    }\n\n    private setupCanvas(): void {\n        this.resizeCanvas();\n        window.addEventListener('resize', () => this.resizeCanvas());\n    }\n\n    private resizeCanvas(): void {\n        const rect = this.canvas.getBoundingClientRect();\n        this.canvas.width = rect.width;\n        this.canvas.height = rect.height;\n        \n        // Update player position relative to new canvas height\n        if (this.player) {\n            this.player.y = this.canvas.height - 130;\n        }\n        \n        // Recreate level with new canvas height\n        if (this.level) {\n            this.level = new Level(this.canvas.height);\n        }\n    }\n\n    private setupEventListeners(): void {\n        document.addEventListener('keydown', (e) => {\n            console.log('Key pressed:', e.key, 'Game running:', this.gameRunning);\n            this.keys[e.key] = true;\n            \n            // Restart game on Enter when game is over\n            if (e.key === 'Enter' && !this.gameRunning) {\n                console.log('Attempting to restart game...');\n                this.restartGame();\n                e.preventDefault();\n                return;\n            }\n            \n            // Prevent scrolling on space bar and arrow keys\n            if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Enter'].includes(e.code)) {\n                e.preventDefault();\n            }\n        });\n\n        document.addEventListener('keyup', (e) => {\n            this.keys[e.key] = false;\n            e.preventDefault();\n        });\n    }\n\n    private gameLoop = (): void => {\n        if (!this.gameRunning) return;\n\n        this.update();\n        this.render();\n\n        requestAnimationFrame(this.gameLoop);\n    }\n\n    private update(): void {\n\n        // Jump\n        if (this.keys[' '] && !this.player.isJumping) {\n            this.player.velocityY = -this.player.jumpPower;\n            this.player.isJumping = true;\n        }\n\n        // Apply gravity\n        this.player.velocityY += this.player.gravity;\n        this.player.y += this.player.velocityY;\n\n        // Ground collision\n        const groundY = this.canvas.height - 50;\n        if (this.player.y + this.player.height >= groundY) {\n            this.player.y = groundY - this.player.height;\n            this.player.velocityY = 0;\n            this.player.isJumping = false;\n        }\n\n        // Move camera (side-scrolling)\n        this.cameraX += this.gameSpeed;\n        \n        // Check collision with obstacles\n        const playerWorldX = this.player.x + this.cameraX;\n        if (this.level.checkCollision(playerWorldX, this.player.y, this.player.width, this.player.height)) {\n            this.gameRunning = false;\n            this.gameOverMessage.reset();\n            console.log('Game Over! Hit an obstacle.');\n        }\n    }\n\n    private render(): void {\n        // Clear canvas\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n        // Draw level (background, ground, obstacles)\n        this.level.render(this.ctx, this.cameraX);\n\n        // Draw player sprite (always at fixed position on screen)\n        if (this.playerSprite.complete) {\n            this.ctx.drawImage(\n                this.playerSprite,\n                this.player.x,\n                this.player.y,\n                this.player.width,\n                this.player.height\n            );\n        } else {\n            // Fallback rectangle while sprite loads\n            this.ctx.fillStyle = this.player.color;\n            this.ctx.fillRect(this.player.x, this.player.y, this.player.width, this.player.height);\n        }\n\n        // Draw UI\n        if (this.gameRunning) {\n            this.ctx.fillStyle = '#000';\n            this.ctx.font = '16px Arial';\n            this.ctx.fillText('Press SPACE to jump', 10, 30);\n            this.ctx.fillText(`Distance: ${Math.floor(this.cameraX / 10)}m`, 10, 50);\n        } else {\n            // Draw game over screen with animations\n            const distance = this.cameraX;\n            const deltaTime = Date.now() - this.lastTime;\n            this.gameOverMessage.render(this.ctx, this.canvas.width, this.canvas.height, distance, deltaTime);\n        }\n    }\n\n    public run(): void {\n        console.log('Starting browser side scroller...');\n        this.gameRunning = true;\n        requestAnimationFrame(this.gameLoop);\n    }\n\n    public stop(): void {\n        this.gameRunning = false;\n    }\n\n    private restartGame(): void {\n        console.log('Restarting game...');\n        \n        // Reset player position and state\n        this.player.x = 50;\n        this.player.y = this.canvas.height - 130;\n        this.player.velocityY = 0;\n        this.player.isJumping = false;\n        \n        // Reset camera and game state\n        this.cameraX = 0;\n        this.gameRunning = true;\n        \n        // Reset level and game over message\n        this.level = new Level(this.canvas.height);\n        this.gameOverMessage.reset();\n        \n        // Clear any held keys\n        this.keys = {};\n        \n        // Restart the game loop\n        requestAnimationFrame(this.gameLoop);\n        \n        console.log('Game restarted successfully!');\n    }\n}","import { BrowserSideScroller } from './browser-side-scroller';\n\nnew BrowserSideScroller().run();"],"names":["Level","canvasHeight","themePath","__publicField","response","error","obstacleType","img","config","currentX","y","nextX","secondObstacleType","secondY","generateAheadDistance","cleanupDistance","obstacle","ctx","cameraX","gradient","parallaxOffset","points","i","ground","x","screenX","playerX","playerY","playerWidth","playerHeight","GameOverMessage","canvasWidth","distance","deltaTime","opacity","centerX","centerY","cupY","achievement","pulseAlpha","meters","star","index","twinkle","currentSize","size","angle","x1","y1","BrowserSideScroller","spritePath","rect","groundY","playerWorldX"],"mappings":"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"}